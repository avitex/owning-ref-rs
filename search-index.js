var N=null,E="",T="t",U="u",searchIndex={};
var R=["An owning reference.","Typedef of a owning reference that uses a…","Typedef of a mutable owning reference that uses a…","Erased","The type of handle to be encapsulated by the OwningHandle.","Given an appropriately-long-lived pointer to ourselves,…","Converts `self` into a new owning reference that points at…","owningref","Tries to convert `self` into a new owning reference that…","result","Creates a new owning reference from a owner initialized to…","new_assert_stable_address","Like `new`, but doesn’t require `O` to implement the…","owningrefmut","map_owner","Converts `self` into a new owning reference with a…","map_owner_box","Converts `self` into a new owning reference where the…","erase_owner","Erases the concrete base type of the owner with a trait…","as_owner","A reference to the underlying owner.","into_owner","Discards the reference and retrieves the owner.","Create a new OwningHandle. The provided callback will be…","try_from","try_into","borrow_mut","type_id","ordering","partial_cmp","deref_mut","formatter","IntoErased","ToHandle","ToHandleMut","OwningRef","OwningRefMut","OwningHandle","An unsafe marker trait for types that deref to a stable…","An unsafe marker trait for types where clones deref to the…"];

searchIndex["owning_ref"]={"doc":R[0],"i":[[8,"StableAddress","owning_ref",R[39],N,N],[8,"CloneStableAddress",E,R[40],N,N],[3,R[36],E,R[0],N,N],[3,R[37],E,"An mutable owning reference.",N,N],[3,R[38],E,"`OwningHandle` is a complement to `OwningRef`. Where…",N,N],[6,"BoxRef",E,"Typedef of a owning reference that uses a `Box` as the…",N,N],[6,"VecRef",E,"Typedef of a owning reference that uses a `Vec` as the…",N,N],[6,"StringRef",E,"Typedef of a owning reference that uses a `String` as the…",N,N],[6,"RcRef",E,"Typedef of a owning reference that uses a `Rc` as the owner.",N,N],[6,"ArcRef",E,"Typedef of a owning reference that uses a `Arc` as the…",N,N],[6,"RefRef",E,"Typedef of a owning reference that uses a `Ref` as the…",N,N],[6,"RefMutRef",E,"Typedef of a owning reference that uses a `RefMut` as the…",N,N],[6,"MutexGuardRef",E,"Typedef of a owning reference that uses a `MutexGuard` as…",N,N],[6,"RwLockReadGuardRef",E,R[1],N,N],[6,"RwLockWriteGuardRef",E,R[1],N,N],[6,"BoxRefMut",E,"Typedef of a mutable owning reference that uses a `Box` as…",N,N],[6,"VecRefMut",E,"Typedef of a mutable owning reference that uses a `Vec` as…",N,N],[6,"StringRefMut",E,"Typedef of a mutable owning reference that uses a `String`…",N,N],[6,"RefMutRefMut",E,"Typedef of a mutable owning reference that uses a `RefMut`…",N,N],[6,"MutexGuardRefMut",E,R[2],N,N],[6,"RwLockWriteGuardRefMut",E,R[2],N,N],[6,"ErasedBoxRef",E,"Typedef of a owning reference that uses an erased `Box` as…",N,N],[6,"ErasedRcRef",E,"Typedef of a owning reference that uses an erased `Rc` as…",N,N],[6,"ErasedArcRef",E,"Typedef of a owning reference that uses an erased `Arc` as…",N,N],[6,"ErasedBoxRefMut",E,"Typedef of a mutable owning reference that uses an erased…",N,N],[8,R[3],E,"Helper trait for an erased concrete type an owner…",N,N],[8,R[33],E,"Helper trait for erasing the concrete type of what an…",N,N],[16,R[3],E,"Owner with the dereference type substituted to `Erased`.",0,N],[10,"into_erased",E,"Perform the type erasure.",0,[[]]],[8,R[34],E,"Trait to implement the conversion of owner to handle for…",N,N],[16,"Handle",E,R[4],1,N],[10,"to_handle",E,R[5],1,[[]]],[8,R[35],E,"Trait to implement the conversion of owner to mutable…",N,N],[16,"HandleMut",E,R[4],2,N],[10,"to_handle_mut",E,R[5],2,[[]]],[11,"new",E,R[10],3,[[["o"]],["self"]]],[11,R[11],E,R[12],3,[[["o"]],["self"]]],[11,"map",E,R[6],3,[[["f"]],[[R[7]],["sized"]]]],[11,"map_with_owner",E,R[6],3,[[["f"]],[[R[7]],["sized"]]]],[11,"try_map",E,R[8],3,[[["f"]],[[R[7]],[R[9],[R[7]]]]]],[11,"try_map_with_owner",E,R[8],3,[[["f"]],[[R[7]],[R[9],[R[7]]]]]],[11,R[14],E,R[15],3,[[["f"]],[R[7]]]],[11,R[16],E,R[17],3,[[],[["box"],[R[7],["box"]]]]],[11,R[18],E,R[19],3,[[],[R[7]]]],[11,R[20],E,R[21],3,[[["self"]],["o"]]],[11,R[22],E,R[23],3,[[],["o"]]],[11,"new",E,R[10],4,[[["o"]],["self"]]],[11,R[11],E,R[12],4,[[["o"]],["self"]]],[11,"map",E,"Converts `self` into a new shared owning reference that…",4,[[["f"]],[[R[7]],["sized"]]]],[11,"map_mut",E,"Converts `self` into a new mutable owning reference that…",4,[[["f"]],[[R[13]],["sized"]]]],[11,"try_map",E,"Tries to convert `self` into a new shared owning reference…",4,[[["f"]],[[R[7]],[R[9],[R[7]]]]]],[11,"try_map_mut",E,"Tries to convert `self` into a new mutable owning…",4,[[["f"]],[[R[9],[R[13]]],[R[13]]]]],[11,R[14],E,R[15],4,[[["f"]],[R[13]]]],[11,R[16],E,R[17],4,[[],[["box"],[R[13],["box"]]]]],[11,R[18],E,R[19],4,[[],[R[13]]]],[11,R[20],E,R[21],4,[[["self"]],["o"]]],[11,"as_owner_mut",E,"A mutable reference to the underlying owner.",4,[[["self"]],["o"]]],[11,R[22],E,R[23],4,[[],["o"]]],[11,"new",E,"Create a new `OwningHandle` for a type that implements…",5,[[["o"]],["self"]]],[11,"new_mut",E,"Create a new mutable `OwningHandle` for a type that…",5,[[["o"]],["self"]]],[11,"new_with_fn",E,R[24],5,[[["o"],["f"]],["self"]]],[11,"try_new",E,R[24],5,[[["o"],["f"]],[R[9]]]],[11,R[20],E,"A getter for the underlying owner.",5,[[["self"]],["o"]]],[11,R[22],E,"Discards the dependent object and returns the owner.",5,[[],["o"]]],[11,"to_owned",E,E,3,[[["self"]],[T]]],[11,"clone_into",E,E,3,[[["self"],[T]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[25],E,E,3,[[[U]],[R[9]]]],[11,R[26],E,E,3,[[],[R[9]]]],[11,R[27],E,E,3,[[["self"]],[T]]],[11,"borrow",E,E,3,[[["self"]],[T]]],[11,R[28],E,E,3,[[["self"]],["typeid"]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[25],E,E,4,[[[U]],[R[9]]]],[11,R[26],E,E,4,[[],[R[9]]]],[11,R[27],E,E,4,[[["self"]],[T]]],[11,"borrow",E,E,4,[[["self"]],[T]]],[11,R[28],E,E,4,[[["self"]],["typeid"]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[25],E,E,5,[[[U]],[R[9]]]],[11,R[26],E,E,5,[[],[R[9]]]],[11,R[27],E,E,5,[[["self"]],[T]]],[11,"borrow",E,E,5,[[["self"]],[T]]],[11,R[28],E,E,5,[[["self"]],["typeid"]]],[11,"as_mut",E,E,4,[[["self"]],[T]]],[11,"clone",E,E,3,[[["self"]],["self"]]],[11,"as_ref",E,E,3,[[["self"]],[T]]],[11,"as_ref",E,E,4,[[["self"]],[T]]],[11,R[30],E,E,3,[[["self"]],[["option",[R[29]]],[R[29]]]]],[11,R[30],E,E,4,[[["self"]],[["option",[R[29]]],[R[29]]]]],[11,"eq",E,E,3,[[["self"]],["bool"]]],[11,"eq",E,E,4,[[["self"]],["bool"]]],[11,"cmp",E,E,3,[[["self"]],[R[29]]]],[11,"cmp",E,E,4,[[["self"]],[R[29]]]],[11,"from",E,E,3,[[["o"]],["self"]]],[11,"from",E,E,4,[[["o"]],["self"]]],[11,"from",E,E,3,[[[R[13]]],["self"]]],[11,R[31],E,E,5,[[["self"]]]],[11,R[31],E,E,4,[[["self"]],[T]]],[11,"hash",E,E,3,[[["self"],["h"]]]],[11,"hash",E,E,4,[[["self"],["h"]]]],[11,"deref",E,E,5,[[["self"]]]],[11,"deref",E,E,3,[[["self"]],[T]]],[11,"deref",E,E,4,[[["self"]],[T]]],[11,"fmt",E,E,3,[[["self"],[R[32]]],[[R[9],["error"]],["error"]]]],[11,"fmt",E,E,4,[[["self"],[R[32]]],[[R[9],["error"]],["error"]]]],[11,"fmt",E,E,6,[[["self"],[R[32]]],[[R[9],["error"]],["error"]]]],[11,"borrow",E,E,3,[[["self"]],[T]]]],"p":[[8,R[33]],[8,R[34]],[8,R[35]],[3,R[36]],[3,R[37]],[3,R[38]],[8,R[3]]]};
searchIndex["stable_deref_trait"]={"doc":"This module defines an unsafe marker trait, StableDeref,…","i":[[8,"StableDeref","stable_deref_trait",R[39],N,N],[8,"CloneStableDeref",E,R[40],N,N]],"p":[]};
initSearch(searchIndex);addSearchOptions(searchIndex);